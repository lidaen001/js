<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>Page Title</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

</head>

<body>
    <script>
        function scream(animal) {
            switch (animal) {
                case "dog":
                    document.write("wang");
                    return;
                case "mao":
                    document.write("wmiao");
                default:
                    return;
            }
            return;
        }

        function reverse() {
            var str = window.prompt('input');
            var re = ""
            for (var i = str.length - 1; i >= 0; i--) {
                re += tras(str.charAt(i));
            }
            document.write(re);
        }

        function tras(target) {
            switch (target) {
                case "1":

                    return "一"

                case "2":

                    return "二"

            }
        }

        function jc(num) {
            if (num == 1) {
                return 1;
            } else {
                return num * jc(num - 1);
            }

        }

//     预编译对于js来说，首先会有一个预编译期的过程，那么在家个预编译期中会发生什么？
// 预编译：有函数预编译AO，全局预编译GO
// 预编译是发生在函数执行的前一刻。
// (函数)预编译分四个步骤：
// function test(a,b){
// console.log(a);
// var c = 123;
// console.log©;
// function a(){};//这个是函数声明
// console.log(b);
// var b = function c(){};//这个是函数表达式
// console.log(b);
// }
// test(1,3);

// 1：创建一个AO对象（activation object）,AO{}
// 2: 将函数内所有的形参和变量声明（的名）储存到ao对象中，value为undifined
// AO{
// a:undefined,
// b:undefined,
// c:undefined
// }
// 3:将形参和实参进行统一。
// AO{
// a:1,
// b:3,
// c:undefined
// }
// 4:将所有的函数声明的函数名作为ao对象中的key,函数整体内容为value储存到ao对象中
// AO{
// a:function a(){},
// b:3,
// c:undefined
// }
// 最后执行函数的结果为：
// function a(){}，123，3，function c(){}

// (全局)预编译分三个步骤：
// 1：生成GO对象 GO｛｝(global object) 这个GO就是window
// 2: 将全局的变量声明（的名）储存一GO对象中，value为undefinde
// 3: 将全局的函数声明的函数名作为go对象中的key,函数整体内容为value储存到go对象中

// 作用域链：GO>>AO>>AO
// function a(){
// var b =10;
// function c (){
// var b =123;
// console.log(b);
// function d(){	
// }
// }
// console.log(b);
// console.log©;
// }
// var b =123;
// a();
// 如上代码中会产生一个GO对象，三个AO对象
// 

        //作用域链

        function bar() {
            return foo;
            foo = 10;

            function foo() {

            }
            var foo = 11;
        }
        //console.log(bar);
        //--------------------------------------
        //闭包
        function eater() {
            var food = "";
            var obj = {
                eat: function () {
                    console.log("i am eating" + food);
                    food = "";
                },
                push: function (myFood) {
                    food = myFood;
                }

            }
            return obj;
        } //闭包应用  ；
        var earter1 = eater();

        function add() {
            //闭包实现累加器
            var num = 0;

            function a() {
                num++;
                console.log(num);
            }

            return a;
        }
        var add1 = add(); //分割线；

        //------------------------------------------
        //立即执行函数 （function(){}());w3c建议
        //（function(){})();
        (function adc() {
            var a = 123;
            var b = 234;
            //实现  console.log(a+b);
        })

        (function abs(ints) {
            //  console.log((ints>0)?ints:-ints);
        }(-0)); //带参数立即执行
        //-------------
        // function test(){
        //     console.log("djashfuj");
        // }();不能执行 只有表达式才能被执行符号执行；
        //test();
        // ---------
        // var test=function(){
        //     console.log("s");
        // }(); 自动放弃test引用；
        //----------------------
        // function test(a,b,c,d){
        //     console.log(a+b+b+d);
        // }(1,2,3,4);等价下面


        // (1,2,3,4);

        //---------------------------
        // function test(){
        //     var arr=[];
        //     for(var i=0;i<10;i++){
        //         // arr[k]=function(){  //只定义不执行  //arr[i]=函数 引用 具体函数内容不管；等到外部执行；
        //         //     document.write(k+" ");//没有执行 等到保存到外部在执行；
                    
        //         // }   
        //             (function(j){document.write(j)}(i));//解决方法
        //     }
        //     return arr;
        // }
        // var myArr=test();
        // for(var j=0;j<10;j++){
        //     myArr[j]();
        // }

        //-----------------------------
    </script>
</body>

</html>